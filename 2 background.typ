= 背景介绍 <background>

== 前置知识

=== 霍尔逻辑
20 世纪60 年代，Floyd、Hoare 提出了霍尔逻辑@HoareLogic，并基于此逻辑表达和验证程序的正确性。霍尔逻辑引入了霍尔三元组$\{P} c \{Q}$，其中$c$是一段序，$P$和$Q$叫做前条件和后条件。该三元组表示如果程序𝑐执行前的状态满足条件$P$，那么程序执行结束后的状态必然满足条件$Q$。例如，在简单的语言 IMP（只有条件、循环、赋值、顺序四种构造）中，有一套简洁的推理规则：

#figure(
  image("images/hl_rules.png", width: 65%)
)
HOARE-ASGN规则表示赋值的语句相关规则，其中$P[E\/x]$表示用赋值的右值来替换 $P$ 中的符号 $x$ 。例如，${ x=6 }  x≔x+10 {x=16}$  是有效的霍尔三元组，因为我们可以通过HOARE-ASGN得到${x+10=16}  x≔x+10 {x=16}$，之后再化简前条件得到。

HOARE-SEQ表示程序顺序连接的情况。一种直观的解释是：如果程序 $S$ 会将程序状态从 $P$ 转移到 $Q$ ，程序 $T$ 会将程序状态从 $Q$ 转移到 $R$ ，那么顺次执行 $S;T$ 会将程序状态从 $P$ 转移到 $R$ 。

HOARE-IF表示程序分支的情况。我们需要在先证明True / False两个分支（在额外添加分支条件的约束作为前条件以后）同时满足前条件 $P$ 和后条件 $Q$ 后，我们可以“合并”两个分支并得到$P$、$Q$分别作为前条件、后条件的霍尔三元组。

HOARE-CONSEQ 规则表示，一个霍尔三元组增强前条件或减弱后条件后依然成立。

在HOARE-WHILE规则中， $I$ 被称为循环不变量(Loop Invariant)，即程序每次执行到循环的入口处时，程序状态保持的性质。寻找合适的循环不变量是证明霍尔三元组过程中最具挑战性的部分之一。这不仅要求循环不变量能够描述循环入口处的性质，还需确保其强度适中，使其在连接上下文时能够应用HOARE-CONSEQ 规则和 HOARE-SEQ 规则。例如，在下面一个包含while的程序中，合适的循环不变量是$\{s=i(i-1)\/2 and i <= n + 1}$。
#figure(
  image("images/hl_example.png", width: 25%)
)

=== 分离逻辑

Hoare提出霍尔逻辑的原文中，由于IMP语言十分简单，关于程序状态的谓词（即上述提到的前条件、后条件）并不需要做出精心设计，使用类似 ${x> 15}$ 之类的简单的算数逻辑谓词进行描绘，其中 x 是一个程序中的一个变量名。然而，如果要处理更加复杂的程序，使用如此简单的谓词来表示程序状态，将变得不可行。

分离逻辑就是这样一种描述程序状态的谓词，主要用来处理涉及指针和动态内存分配的程序。核心在于引入分离合取（separating conjunction，通常记作 “$∗$”），将整个内存状态划分为互不重叠的区域。比如：$p_1 mapsto 2 ∗ p_2 mapsto 2$
表示 $p_1$ 和 $p_2$ 分别指向值为 2 的内存单元，且这两块内存地址不重叠；而如果想要表示 $p_1$ 和 $p_2$别名地指向同一块值为2的内存单元，则需要使用$p_1 mapsto 2 ∗ "pure"(p_1 = p_2)$来表达。

除了简介地描述“内存不交”外，分离逻辑还隐式限定了程序可以访问的内存区域：一个断言不仅声明某块内存的布局和内容，也隐式赋予了当前命令对该内存片段的“访问权限”。因此，如果某段代码仅在断言中“拥有” $p_1 mapsto 2$的内存片段，则在该代码中无法读写$p_1$之外的任何其他区域。

Frame rule 是基于 separating conjunction 定义得到的一个重要规则：

#figure(
  image("images/frame.png", width: 35%)
)

该规则形式化了我们对程序“局部性”的直觉：即在验证一段代码时，我们仅需关注这段代码访问的内存区域，而无需考虑完整的内存状态。这一条规则显著降低了验证的复杂性，从而提高了验证过程的效率。

=== 逻辑模型

在形式化验证的过程中，我们需要在特定的逻辑框架中对程序的行为进行建模。虽然程序语言本身可以拥有一套形式化语义， 但其语义往往过于复杂和底层，尤其是命令式语言，这使得我们难以进行有效的推理。因此，我们需要依靠逻辑框架进行更加抽象的建模。常用的逻辑框架包括Rocq（即改名后的Coq）、HOL[8]、Lean[9]等。其中，Rocq 基于归纳构造演算（Calculus of Inductive Constructions），在形式化方法领域得到了广泛应用。图 1（b）展示了 Rocq 中对于图 1（a）代码的逻辑模型（此处进行了简化处理）。natlist 是一个归纳定义(inductive definition)，即一个自然数列表（natlist）要么是空列表(nil)，要么是一个元素通过连接（cons）到另一个列表上；这个归纳定义用于对图 1（a）中的struct list 类型构造的链表进行建模。app和rev 是通过在 natlist 上实现结构化递归定义的 natlist 上的拼接、反转操作；其中rev 函数用来对图 1 （a）代码中的reverse 函数进行建模。

```Ocaml
Inductive natlist :Type敷发 :=
  | nil
  | cons (n:nat) (l:natlist)
Fixpoint app(l1 l2:natlist) : natlist
  := match l1 with
  | nil => 12
  | cons h t => cons h (app t 12)
  end.
Fixpoint rev (l:natlist) : natlist :=
  match l with
  | nil => nil
  | cons h t => app (rev t) (cons h nil)
  end.
Fixpoint listrep (l:natlist) (x:val) : mpred :=
  match l with
  | nil => pure(x = NULL)
  | h::l0 => Exists y0 y1. pure(h = y0) * store_list_cell x y0 y1 * listrep l0 y1
  end.
```

为了描述单向链表在内存中的排布，我们在图 1(b)中定义了 listrep 这一分离逻辑的表示谓词（representation predicates）。listrep 通过在natlist 逻辑模型上做结构化递归，实现了对内存中单向链表的描述。具体而言，当natlist 逻辑模型是一个空列表(nil)时，对应的 struct list \*应为空指针 null；当natlist 逻辑模型为一个非空列表，头元素为 h，剩余部分为l0 时，那么对应的struct list \*应该满足：它指向一个struct list，其head 字段的值为h，而 tail 字段的值（通过存在量词引入）y 满足listrep l0 y。由于store_list_cell 和 listrep 之间使用的是分离联结符（\*）而非传统的逻辑与（/\\）进行连接，这一定义还确保了各个列表节点在内存中互不重叠，从而排除了链表中出现循环的可能性。

== 问题：规约中的存在量词

考虑这样一个问题：程序中有一个指针变量 p，我们想在规约里表达“p 所指向的 int 值小于 100”。程序员的直觉写法是: \*p < 100。但规约是在逻辑层书写的，此时内存模型已被抽象为符号状态，不应出现“解引用”操作。为此，通常借助存在量词引入一个逻辑符号 v 来代表 p 指向的值：

$exists v. (p mapsto v) \* "pure"(v < 100)$

此法虽可行，却令程序员感到困惑：首先，存在量词本身对多数人来说并不直观，其次在这里我们更希望描述一个确定的值，而不是“存在某个值”。

为消除这种心智负担，验证社区通常采用*幽灵代码（ghost code）*技术——在程序中静态声明但在运行时擦除的辅助变量。针对本例，可在程序逻辑层定义一个幽灵变量 v，表示 p 指向的整数，然后直接写出：

$(p mapsto v) \* "pure"(v < 100)$

比起存在量词，这种写法既符合程序员习惯，又显得直观清晰。

更近一步的，我们考虑一段程序的规约（而不仅仅是一个程序状态的刻画），假设我们设计变量可变性(mutability)的语义，我们可以写出如下的示例程序。 

```C 

int f() {
    int val = 0, res = 0, *p = ...;
    ghost int v = 0model;
    *p = 0;
    while(*p < n) 
     Invariant{ p ~~> v * pure(v >= 0) * pure(v < 100) 
                * fact(res = v * (v + 1) / 2) }
    {
        (*p)++;
        res = res + (*p);
        v = v + 1model;
    }
    return res;
}

```

这是一个简单的循环程序。左图使用存在量词（$exists$）书写的规约；右图是使用幽灵变量（用关键词ghostvar标注）书写的规约。可以看到，使用幽灵变量的规约相较于使用存在量词的规约，不仅更加直观易读，也表达出程序两次执行到循环不变量的位置上“p指向int值”之间的关系——后一次是前一次增加1的值。如果和exists版本的规约进行对照的话，我们发现$v := v + 1"model";$语句还提供了更多的证明相关的信息。

虽然两种表达方式上有形式上的差异，但直觉上两种表达方式之间存在明显的“相似性”。这样，我们提出两个问题：

问题一: 如何解释两者之间的相似性？

问题二: 能否利用这种相似性，让我们将带有逻辑层幽灵变量的规约和证明，翻译到存在量词式的规约证明？

第三章和第四章将围绕这两个问题展开。在多数验证工具中，程序规约的验证问题会被分解为若干个直线霍尔三元组（straight-line Hoare Triple）。为了简洁但又不失一般性，我们将在后续章节中采用以下两个直线霍尔三元组的示例来说明方法：

$\{exists x. (p mapsto x) \* "pure"(x < 100) }
\*p := \*p + 15;
\{exists x. (p mapsto x) \* "pure"(x < 115) }
$

$\{(p mapsto v) \* "pure"(v < 100) }
\*p := \*p + 15; v := v + 15"model";
\{(p mapsto v) \* "pure"(v < 115) }
$