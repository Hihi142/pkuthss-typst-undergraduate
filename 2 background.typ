= 背景介绍 <background>

== 前置知识

=== 霍尔逻辑
20 世纪60 年代，Floyd、Hoare 提出了霍尔逻辑@HoareLogic，并基于此逻辑表达和验证程序的正确性。霍尔逻辑引入了霍尔三元组$\{P} c \{Q}$，其中$c$是一段序，$P$和$Q$叫做前条件和后条件。该三元组表示如果程序𝑐执行前的状态满足条件$P$，那么程序执行结束后的状态必然满足条件$Q$。例如，在简单的语言 IMP（只有条件、循环、赋值、顺序四种构造）中，有一套简洁的推理规则：

#figure(
  image("images/hl_rules.png", width: 65%),
  caption: "IMP上霍尔逻辑的五条推理规则"
)
HOARE-ASGN规则表示赋值的语句相关规则，其中$P[E\/x]$表示用赋值的右值来替换 $P$ 中的符号 $x$ 。例如，${ x=6 }  x≔x+10 {x=16}$  是有效的霍尔三元组，因为我们可以通过HOARE-ASGN得到${x+10=16}  x≔x+10 {x=16}$，之后再化简前条件得到。

HOARE-SEQ表示程序顺序连接的情况。一种直观的解释是：如果程序 $S$ 会将程序状态从 $P$ 转移到 $Q$ ，程序 $T$ 会将程序状态从 $Q$ 转移到 $R$ ，那么顺次执行 $S;T$ 会将程序状态从 $P$ 转移到 $R$ 。

HOARE-IF表示程序分支的情况。我们需要在先证明True / False两个分支（在额外添加分支条件的约束作为前条件以后）同时满足前条件 $P$ 和后条件 $Q$ 后，我们可以“合并”两个分支并得到$P$、$Q$分别作为前条件、后条件的霍尔三元组。

HOARE-CONSEQ 规则表示，一个霍尔三元组增强前条件或减弱后条件后依然成立。

在HOARE-WHILE规则中， $I$ 被称为循环不变量(Loop Invariant)，即程序每次执行到循环的入口处时，程序状态保持的性质。寻找合适的循环不变量是证明霍尔三元组过程中最具挑战性的部分之一。这不仅要求循环不变量能够描述循环入口处的性质，还需确保其强度适中，使其在连接上下文时能够应用HOARE-CONSEQ 规则和 HOARE-SEQ 规则。例如，在下面一个包含while的程序中，合适的循环不变量是$\{s=i(i-1)\/2 and i <= n + 1}$。
#figure(
  image("images/hl_example.png", width: 25%)
)

=== 分离逻辑

Hoare提出霍尔逻辑的原文中，由于IMP语言十分简单，关于程序状态的谓词（即上述提到的前条件、后条件）并不需要做出精心设计，使用类似 ${x> 15}$ 之类的简单的算数逻辑谓词进行描绘，其中 x 是一个程序中的一个变量名。然而，如果要处理更加复杂的程序，使用如此简单的谓词来表示程序状态，将变得不可行。

分离逻辑就是这样一种描述程序状态的谓词，主要用来处理涉及指针和动态内存分配的程序。核心在于引入分离合取（separating conjunction，通常记作 “$∗$”），将整个内存状态划分为互不重叠的区域。比如：$p_1 mapsto 2 ∗ p_2 mapsto 2$
表示 $p_1$ 和 $p_2$ 分别指向值为 2 的内存单元，且这两块内存地址不重叠；而如果想要表示 $p_1$ 和 $p_2$别名地指向同一块值为2的内存单元，则需要使用$p_1 mapsto 2 ∗ "pure"(p_1 = p_2)$来表达。

除了简介地描述“内存不交”外，分离逻辑还隐式限定了程序可以访问的内存区域：一个断言不仅声明某块内存的布局和内容，也隐式赋予了当前命令对该内存片段的“访问权限”。因此，如果某段代码仅在断言中“拥有” $p_1 mapsto 2$的内存片段，则在该代码中无法读写$p_1$之外的任何其他区域。

Frame Rule是基于 separating conjunction 定义得到的一个重要规则：

#figure(
  image("images/frame.png", width: 35%), 
  caption: "分离逻辑中的Frame规则"
)

该规则形式化了我们对程序“局部性”的直觉：即在验证一段代码时，我们仅需关注这段代码访问的内存区域，而无需考虑完整的内存状态。

除了Frame Rule以外，分离逻辑中还有一条Call规则：

#figure(
  image("images/sl-call.png", width: 75%),
  caption: "分离逻辑中的函数调用的Call规则"
)

Call Rule 可视作 Frame Rule 在函数调用场景下的特例——程序片段 $c$ 恰好是一次函数调用时的情况。与 Frame Rule 一样，Call Rule 将函数的“局部性”形式化：在调用 $f$ 时，除了满足其前置条件所需的那部分内存，剩余的内存资源 $R$ 无论是什么，都保持不变。

Frame Rule 与 Call Rule 的协同作用让我们在验证过程中只需关注程序所被允许访问的那段内存，而无需处理内存的全貌。这大大简化了证明中对内存状态的跟踪，从而显著提升了验证效率。

=== 逻辑模型

在形式化验证的过程中，我们需要在特定的逻辑框架中对程序的行为进行建模。虽然程序语言本身可以拥有一套形式化语义， 但其语义往往过于复杂和底层，尤其是命令式语言，这使得我们难以进行有效的推理。因此，我们需要依靠逻辑框架进行更加抽象的建模。常用的逻辑框架包括Rocq（即改名后的Coq）、HOL[8]、Lean[9]等。其中，Rocq 基于归纳构造演算（Calculus of Inductive Constructions），在形式化方法领域得到了广泛应用。图 1（b）展示了 Rocq 中对于图 1（a）代码的逻辑模型（此处进行了简化处理）。natlist 是一个归纳定义(inductive definition)，即一个自然数列表（natlist）要么是空列表(nil)，要么是一个元素通过连接（cons）到另一个列表上；这个归纳定义用于对图 1（a）中的struct list 类型构造的链表进行建模。app和rev 是通过在 natlist 上实现结构化递归定义的 natlist 上的拼接、反转操作；其中rev 函数用来对图 1 （a）代码中的reverse 函数进行建模。

```Ocaml
Inductive natlist :Type :=
  | nil
  | cons (n:nat) (l:natlist)
Fixpoint app(l1 l2:natlist) : natlist
  := match l1 with
  | nil => 12
  | cons h t => cons h (app t 12)
  end.
Fixpoint rev (l:natlist) : natlist :=
  match l with
  | nil => nil
  | cons h t => app (rev t) (cons h nil)
  end.
Fixpoint listrep (l:natlist) (x:val) : mpred :=
  match l with
  | nil => pure(x = NULL)
  | h::l0 => Exists y0 y1. pure(h = y0) * store_list_cell x y0 y1 * listrep l0 y1
  end.
```

为了描述单向链表在内存中的排布，我们在图 1(b)中定义了 listrep 这一分离逻辑的表示谓词（representation predicates）。listrep 通过在natlist 逻辑模型上做结构化递归，实现了对内存中单向链表的描述。具体而言，当natlist 逻辑模型是一个空列表(nil)时，对应的 struct list \*应为空指针 null；当natlist 逻辑模型为一个非空列表，头元素为 h，剩余部分为l0 时，那么对应的struct list \*应该满足：它指向一个struct list，其head 字段的值为h，而 tail 字段的值（通过存在量词引入）y 满足listrep l0 y。由于store_list_cell 和 listrep 之间使用的是分离联结符（\*）而非传统的逻辑与（/\\）进行连接，这一定义还确保了各个列表节点在内存中互不重叠，从而排除了链表中出现循环的可能性。

== 问题：规约中的存在量词

考虑这样一个问题：程序中有一个指针变量 p，我们想在规约里表达“p 所指向的 int 值小于 100”。程序员的直觉写法是: \*p < 100。但规约是在逻辑层书写的，此时内存模型已被抽象为符号状态，不应出现“解引用”操作。为此，通常借助存在量词引入一个逻辑符号 v 来代表 p 指向的值：

$exists v. (p mapsto v) ∗ "pure"(v < 100)$

这样的做法虽然可行，却令程序员感到困惑：首先，存在量词本身对于一般的程序员来说并不熟悉；其次，在这里我们更希望描述一个确定的值，而不是“存在某个值”。

为消除这种心智负担，我们可以采用验证社区通常使用的*幽灵代码（ghost code）*技术——在程序中静态声明但在运行时擦除的辅助变量。针对本例，可在程序逻辑层定义一个幽灵变量 v，表示 p 指向的整数，然后直接写出：

$(p mapsto v) ∗ "pure"(v < 100)$

比起存在量词，这种写法既符合程序员习惯，又显得直观清晰。

更近一步的，我们考虑一段程序的规约（而不仅仅是一个程序状态的刻画），假设我们为幽灵变量设计可变的(mutable)的语义，我们可以写出如下的示例程序。 

#figure(
  image("images/problem.png", width: 65%),
  caption: "\"幽灵变量式\"（左）和\"存在量词式\"（右）的两种规约"
)<problem>

这是一个简单的循环程序，Invariant { … } 中标出了用分离逻辑书写的循环不变式。左图采用了一个幽灵变量 v 来撰写规约，右图则直接使用了存在量词。为方便后文叙述，我们将把左图中的方式称为“幽灵变量式规约（及其证明）”，把右图中的方式称为“存在量词式规约（及其证明）”。

相较于存在量词式规约，幽灵变量式规约更加直观、易读。此外，幽灵变量式规约也表达出程序两次执行到循环不变量的位置上“p指向int值”之间的关系——后一次是前一次增加1的值，即$v := v + 1"model";$语句还提供了更多的证明相关的信息。


虽然两种表达在形式上略有不同，但从上述示例可见，循环不变量的唯一区别仅在于存在量词式规约在原有基础上额外添加了一个“exists v”的存在量化。直观上，这两种写法有着天然的对应关系。基于此，我们提出两个问题：

问题一: 如何解释幽灵变量式与相对应存在量词式规约之间的关联？

问题二: 能否借助这种关联，将幽灵变量式的规约与证明翻译为存在量词式的规约与证明？

第 3 章和第 4 章将围绕这两个问题展开讨论。

绝大多数验证工具会将程序规约的验证任务，依据程序的执行路径，分解为若干条“直线”霍尔三元组（straight‐line Hoare triples）。我们用下两条直线霍尔三元组作为例子。

$\{exists x. (p mapsto x) ∗ "pure"(x < 100) }
\*p := \*p + 15;
\{exists y. (p mapsto y) ∗ "pure"(y < 115) }
$

$\{(p mapsto v) ∗ "pure"(v < 100) }
\*p := \*p + 15; v := v + 15"model";
\{(p mapsto v) * "pure"(v < 115) }
$

接下来，工具通过符号执行等技术，将每条霍尔三元组交给谓词转换器（predicate transformer），生成形如分离逻辑蕴含式的验证条件。上述两条三元组会分别被转换为：

$exists x. (p mapsto x + 15) ∗ "pure"(x < 100) 
⊢
exists y. (p mapsto y) ∗ "pure"(y < 115) 
$

$(p mapsto v + 15) ∗ "pure"(v < 100)
⊢
(p mapsto v) * "pure"(v < 115)
$

为了保持简洁性且不失一般性，后续章节将以以上两个分离逻辑蕴含式为例，详细说明所提出的方法。