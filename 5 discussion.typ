= 总结与展望 <discussion>

之前的章节给出了一种利用（逻辑层）上的幽灵变量消除规约中存在量词的方法。本章讲讨论一些其他类似的语言工具是如何处理规约中存在量词，并且进一步讨论本方案为我们新型的程序验证工具设计思想的启发。


== 相关工作 <related>

自从人们开始利用分离逻辑对程序的内存性质进行推理，用来表达程序状态的符号状态变得愈发复杂；程序状态中难免存在很多不能使用直接使用变量名称表达的逻辑对象。不同的分离逻辑工具采用了不同的方式来解决这个问题。

=== VST-A 

VST-A @zhou2023vsta 是一个基于 Rocq（即改名后的 Coq）的 C 语言注释式程序验证器。VST-A 的核心逻辑均在 Coq/Rocq 中形式化，用户只需在 C 源码的适当位置插入断言和不变式，然后工具依次执行以下两步来完成验证：
1. 符号执行：分析函数的控制流，将程序分解为断言之间的“直线”代码片段；
2. VST-A 会将验证条件发往 Coq，再结合已有的 VST 完备性定理进行验证。

VST-A 的后端与 VST 紧密集成，依托 VST 的核心soundness证明，因而具备极高的安全性；同时，由于工具本身对 Rocq 的深度依赖，它更适合由具有丰富证明经验的工程师来使用，而非面向一般开发者。

在处理分离逻辑中的循环不变式时，VST-A 支持使用存在量词来描述复杂的数据结构关系。例如，对于单链表原地翻转的程序，VST-A可以在循环头部写入如下循环不变量：

```C
  while (v) 
    /*@ Inv
        exists l1 l2,
          l == rev(l1) ++ l2 &&
          listrep(l1, w) * listrep(l2, v)
    */
  {
    t = v->tail;
    v->tail = w;
    w = v;
    v = t;
  }
```
正如之前所提到的，这种规约书写方式对于程序员来说十分不直观。 但是，VST-A的用户更多都是有一定经验的证明专家，这种规约不会给VST-A的用户造成太大的困扰。
不过，这种仅依赖存在量词的规范方法在逻辑层面非常简单，不需要扩展底层证明理论，也为今后研究更复杂的逻辑引入策略奠定了基础。

=== Dafny

Dafny @leino2006dafny 是一种集成了内置验证支持的命令式/函数式混合语言。它允许开发者在同一源文件中编写程序及相应的规格（包括前置条件、后置条件和循环不变式等），并通过 SMT 求解器（如 Z3）实现自动或半自动化验证。Dafny 的核心优势在于它为程序验证提供了一套直观且高效的工具链，极大地简化了证明流程。在 Dafny 中，ghost code 是辅助验证的关键机制。通过 `ghost` 关键字声明的变量和函数仅在验证阶段存在，不会出现在编译后的可执行代码中，却能在规范、循环不变式乃至证明脚本中自由地保存和操作逻辑信息。下面演示了一个基于 ghost code 的交换函数示例：
```Cpp
method Swap(a: array<int>, i: int, j: int)
  requires 0 <= i < a.Length && 0 <= j < a.Length
  ensures  a[i] == old(a[j]) && a[j] == old(a[i])
{
  ghost var orig := a[..]    // 幽灵变量，用于保存旧数组供证明使用
  var tmp := a[i]            // 普通变量，用于实际执行的临时存储
  a[i] := a[j]
  a[j] := tmp
}
```
以上例子中，ghost var orig 在验证阶段记录了交换前的数组快照，使得我们可以在 ensures 或更复杂的循环不变式中直接引用 orig，而在运行时代码中不会留下任何痕迹。Dafny 借助 ghost code 实现了验证与执行的彻底分离：所有与证明相关的中间状态均通过 ghost 变量管理，从而既满足了规格语言的表达需求，又不影响程序执行效率。这种设计让用户能够像管理普通变量一样灵活地操控证明信息，提高了验证过程的可读性和可维护性。

除了函数内部的 ghost 变量，Dafny 还支持将 ghost 字段定义在类中，从而将一些逻辑模型绑定在对象里，“存放”在内存中。例如：

```Cpp
class C {
  var a: int  
  ghost var b: bv10
  var d: nat 
}
```
需要注意的是，Dafny 的 ghost 变量设计与本文所述方案有所不同。在 Dafny 中，ghost 变量本身仍与程序语义存在对应关系，拥有与普通程序实体类似的作用域与生命周期；而在本文的设计中，ghost 变量更应理解为“逻辑层”对象，只服务于规约语言层面，与程序层面的实体严格区分。因此，Dafny 的 ghost 系统更易于上手，适合程序员日常使用；而本文的逻辑层 ghost 变量则能够支持更为丰富的规约语言特性。

== 展望：程序验证的新范式 <future>

