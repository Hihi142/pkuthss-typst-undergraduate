= 总结与展望 <discussion>

第 3 章和第 4 章介绍了一种利用逻辑层幽灵变量消除规约中存在量词的方法。本章首先将与其他类似的验证工具进行对比，分析它们在处理规约中存在量词方面的不同思路（第 5.1 节）。随后，我们聚焦于降低使用者在形式化验证中所面临的认知负担这一核心问题。我们应该怎样设计我们的形式化验证工具，来降低用户的认知负担？第 5.2 节和第 5.3 节将分基于本文提出的方法，对这个问题做出一定程度的探索和回答。

== 相关工作 <related>

自从人们开始利用分离逻辑对程序的内存性质进行推理，用来表达程序状态的符号状态变得愈发复杂；程序状态中难免存在很多不能使用直接使用变量名称表达的逻辑对象。不同的分离逻辑工具采用了不同的方式来解决这个问题。

=== VST-A 

VST-A @zhou2023vsta 是一个基于 Rocq（即改名后的 Coq）的 C 语言注释式程序验证器。VST-A 的核心逻辑均在 Coq/Rocq 中形式化，用户只需在 C 源码的适当位置插入断言和不变式，然后工具依次执行以下两步来完成验证：
1. 符号执行：分析函数的控制流，将程序分解为断言之间的“直线”代码片段；
2. VST-A 会将验证条件发往 Coq，再结合已有的 VST 完备性定理进行验证。

VST-A 的后端与 VST 紧密集成，依托 VST 的核心soundness证明，因而具备极高的安全性；同时，由于工具本身对 Rocq 的深度依赖，它更适合由具有丰富证明经验的工程师来使用，而非面向一般开发者。

在处理分离逻辑中的循环不变式时，VST-A 支持使用存在量词来描述复杂的数据结构关系。例如，对于单链表原地翻转的程序，VST-A可以在循环头部写入如下循环不变量：

```C
  while (v) 
    /*@ Inv
        exists l1 l2.
          pure(l == rev(l1) ++ l2) *
          listrep(l1, w) * listrep(l2, v)
    */
  {
    t = v->tail;
    v->tail = w;
    w = v;
    v = t;
  }
```
正如之前所提到的，这种规约书写方式对于程序员来说十分不直观。 但是，VST-A的用户更多都是有一定经验的证明专家，这种规约不会给VST-A的用户造成太大的困扰。
不过，这种仅依赖存在量词的规范方法在逻辑层面非常简单，不需要扩展底层证明理论，也为今后研究更复杂的逻辑引入策略奠定了基础。

=== Dafny

Dafny @leino2006dafny 是一种集成了内置验证支持的命令式/函数式混合语言。它允许开发者在同一源文件中编写程序及相应的规格（包括前置条件、后置条件和循环不变式等），并通过 SMT 求解器（如 Z3）实现自动或半自动化验证。Dafny 的核心优势在于它为程序验证提供了一套直观且高效的工具链，极大地简化了证明流程。在 Dafny 中，ghost code 是辅助验证的关键机制。通过 `ghost` 关键字声明的变量和函数仅在验证阶段存在，不会出现在编译后的可执行代码中，却能在规范、循环不变式乃至证明脚本中自由地保存和操作逻辑信息。下面演示了一个基于 ghost code 的交换函数示例：
```Cpp
method Swap(a: array<int>, i: int, j: int)
  requires 0 <= i < a.Length && 0 <= j < a.Length
  ensures  a[i] == old(a[j]) && a[j] == old(a[i])
{
  ghost var orig := a[..]    // 幽灵变量，用于保存旧数组供证明使用
  var tmp := a[i]            // 普通变量，用于实际执行的临时存储
  a[i] := a[j]
  a[j] := tmp
}
```
以上例子中，ghost var orig 在验证阶段记录了交换前的数组快照，使得我们可以在 ensures 或更复杂的循环不变式中直接引用 orig，而在运行时代码中不会留下任何痕迹。Dafny 借助 ghost code 实现了验证与执行的彻底分离：所有与证明相关的中间状态均通过 ghost 变量管理，从而既满足了规格语言的表达需求，又不影响程序执行效率。这种设计让用户能够像管理普通变量一样灵活地操控证明信息，提高了验证过程的可读性和可维护性。

除了函数内部的 ghost 变量，Dafny 还支持将 ghost 字段定义在类中，从而将一些逻辑模型绑定在对象里，“存放”在内存中。例如：

```Cpp
class C {
  var a: int  
  ghost var b: bv10
  var d: nat 
}
```
需要注意的是，Dafny 的 ghost 变量设计与本文所述方案有所不同。在 Dafny 中，ghost 变量本身仍与程序语义存在对应关系，拥有与普通程序实体类似的作用域与生命周期；而在本文的设计中，ghost 变量更应理解为“逻辑层”对象，只服务于规约语言层面，与程序层面的实体严格区分。因此，Dafny 的 ghost 系统更易于上手，适合程序员日常使用；而本文的逻辑层 ghost 变量则能够支持更为丰富的规约语言特性。

== 反思：用户与自动化的分工 <future>

霍尔逻辑最早被提出时，最初仅仅用于纸笔验证。
1975年，Dijkstra提出了最弱前条件（weakest precondition）、谓词转换器（predicate transformer）@dijkstra1975guarded 等概念。这一突破性思想将验证条件的生成完全“算法化”：计算机通过对程序和规约进行语义分析，自动生成一组逻辑公式（verification conditions），再将这一繁重的推导过程交由计算机来完成。

进入 21 世纪后，计算能力显著提升，而自动化求解算法也不断完善。2008 年，SMT 求解器 Z3 @deMoura2008z3 的问世成为形式化验证的一大里程碑。Z3 擅长高效解决由最弱前条件或验证条件生成器产生的算术、布尔、数组等背景理论约束，使得自动化验证真正从实验室走向工程实践。此后，SMT 和自动定理证明技术飞速发展，从简单算术扩展到不等式、代数数据类型、甚至部分高阶逻辑，这些进展大幅提升了工具对复杂程序验证的自动推理能力，并推动了诸多验证平台的广泛应用。

完全自动化程序验证曾是形式化方法领域的宏大愿景。然而，一些计算理论的结果给这一梦想判了死刑——很多逻辑上的逻辑式是不可判定#footnote("该不可判定性结果基于图灵机模型，在未来更强大的计算范式（如量子计算）下，情形或有所不同。")的，甚至有些逻辑是不完备的。事实上，对于不可判定/不完备的逻辑表达式判定问题，自动求解器也无法百分之百地给出“真”或“假”的答案，它们会返回一个“不确定”(unknown) 的状态。对于不熟悉求解器内部机制的用户来说，这种“灰色结论”极为难以处理：当工具报告某个验证条件“无法判定”时，程序员难以确认程序是否正确；即便他们十分清楚程序如何也不清楚应如何调整输入或提供额外的引导，以便求解器继续推进证明。  

例如，在 Verus @lattuada2023verus 论文中给出的斐波那契示例（如@verus_fib）中，作者实现了一个基于迭代的 Fibonacci 函数，并希望证明它等价于定义为递归模型函数的规范版本。要让后台的 SMT 求解器成功完成该证明，用户需要显式提示斐波那契的单调不下降性：即$∀n. "fib"(n) ≤ "fib"(n+1)$。

#figure(
  image("images/verus_fib.png", width: 85%),
  caption: "Verus论文中，斐波那契函数的示例"
)<verus_fib>

大多数使用者而言往往不会想到插入这样一条中间引理。于是，如果没有手工补充这一提示，验证过程就会卡在“无法判定”的状态，这大大削弱了工具的可用性和易用性。

近年来，随着求解器的自动化能力提高遇到了一个瓶颈；研究者们开始侧重验证工具的可用性、易用性等的问题。

(To be Checked)从这个角度来看我们的工作，我们会发现：从关联上可以解读到——将原本存在量词的规约改写成幽灵变量的形式，其实要求用户提供更多的证明信息——幽灵变量恰当的赋值语句就是存在量词版本中，hexists-intro规则中我们需要提供的witness。换言之，我们得到的，出了直观性，还有通过语言设计，讲提供existential witness这一项工作，分工给了用户；这项分工不会对于用户造成很大的困扰（因为ghost code本身的形式是符合程序直观的，也不会有很大的学习困难）；而带来的好处则是：程序员不再会因为exists的问题得到unknown。从逻辑推导的角度来看（参考第3章），幽灵变量的设计，等于是讲hexists-intro和hexists-elim两条规则完全交给了用户来处理； 而求解器所需处理的逻辑中将完全没有这两条规则。

事实上，近年来的一些工作也蕴含着这样的思想，下面将列举两个。

=== Verus

Verus @lattuada2023verus 是一个基于 Rust 的形式化验证工具，它直接复用 Rust 强大的类型系统，让用户在同一语言环境中编写程序、规范与证明，并通过 Rust 的线性类型与借用检查机制确保对内存与资源的安全操作。其核心设计之一是引入“线性许可”（linear permissions）概念：每个许可都由线性类型描述，代表对内存块、指针或并发资源的独占访问权，既能精准跟踪资源的使用，又能在并发场景下保持安全性。Verus引入了一套模式系统（mode system），将代码分为三种模式：规约模式即传统的逻辑模型，仅用于表达程序的正确性；可执行模式即程序要执行的代码；证明模式介于两者之间，这种代码在实际编译、运行时会被擦除，本身既表达逻辑推导，也需要尊总和满足线性和借用约束。通过这两项设计，Verus 在保留高自动化验证能力的同时，为开发者提供了与 Rust 原生编程体验高度一致的形式化验证流程。

#figure(
  image("images/verus_perm.png", width: 85%),
  caption: "Verus中关于线性许可(Linear Permission)的一个示例"
) <verus_perm>

@verus_perm 展示了 Verus 如何利用线性许可来验证 unsafe Rust 代码的内存安全性。图 (b) 的第 3–6 行首先调用底层分配函数，返回一个原始指针，并将其封装为 PPtr<u64> 类型；与此同时，我们还得到了一个名为 perm 的变量，它持有对这块新分配内存的线性许可（即独占访问权）。

在图 (a) 中，从第 14 行开始的 read 函数演示了对 PPtr<u64> 的只读操作：除了传入原始指针之外，它还以只读借用的形式接受 perm，确保在整个读取过程中只有该函数持有对内存的访问权。对应地，write 函数则以可变借用方式接收 perm，以验证写操作的合法性和安全性。

回到图 (b)，第 23 行调用 free 时，perm 的所有权会被移交给释放函数，并且 free 不会将 perm 返还。这意味着在类型层面上，函数调用完成后，不可能再对已释放的内存进行任何访问，从而从根本上防止悬垂指针和重释放等常见内存错误。

上述示例充分展示了线性许可的作用。线性许可机制依赖于 Rust 的所有权类型系统（ownership type system），将内存片段的“可访问性”绑定到“线性许可”变量上，从而在类型层面确保对该内存的独占访问。

若跳出 Rust 视角，从分离逻辑角度审视“证明模式”，会发现其实它将分离逻辑的证明义务通过手工编写的“证明代码”完全交由用户执行，而非交由自动化工具：用户显式地操作并传递线性许可，本质上就是在提供提示以实现分离逻辑Call规则（见下图）中的consume(进入函数时，“消耗”前条件中对应的内存资源)/（从函数中返回时，“产生”后条件中对应的内存资源）。

#figure(
  image("images/SL-call.png", width: 70%),
  caption: "分离逻辑中的关于函数调用的Call规则"
)

从这个视角出发，Verus 的设计堪称精妙。它并非在 Rust 之上简单叠加一层外部验证语言，而是将分离逻辑call规则的consume/produce机制无缝融入 Rust 原生的所有权与借用类型系统中。Rust用户在沿用熟悉的所有权约束的同时，便能完成分离逻辑的相关证明。通过这种方式，分离逻辑的关键证明义务完全交由用户承担，尽管减少了自动化程度，却并未显著削弱工具的可用性与易用性。

=== Predictable Verification 

《Predictable Verification using Intrinsic Definitions》@murali2024predictable 一文针对“自动化结果不可预测”这一痛点，提出了一种可判定的验证范式。直观来看，要让验证条件变得可判定，似乎必须大幅削弱规格语言的表达能力，而该工作巧妙地将程序规格内嵌于数据结构的“*内部定义*”（Intrinsic Definition）之中，使得用户只需通过幽灵代码以及简单的算术、逻辑表达式书写程序规约，便能表达丰富的规约，且所生成的验证条件可落入可判定逻辑。

下图展示了单链表的内部定义示例：

#figure(
  image("images/intrinsic.png", width: 100%),
  caption: "单向链表的内部定义"
)

这个内部定义规定了双链表的结构。在此定义中，prev、next 和 key 是链表节点的普通字段；keys 与 rank 为幽灵变量，其中 keys 表示链表中所有键值的多重集合，构成链表的核心模型；rank 用于保证结构的“递降性”，防止循环并确保链表长度有限#footnote("在有理数域上递降未必意味着有界，但由于 rank 值由幽灵代码赋值产生，且任何一个程序点处执行路径有限，故能保证链表长度有限")。

将上述公式的$forall x$的全称量词，替换为一个谓词的1格式$"LC"(x: "Loc") = ...$，就得到了一个*局部条件*(Local Condition)。这个谓词描述了关于"地址$x$"的性质，只能依赖地址 x 及其邻居信息。对链表所有节点的 LC(x) 取分离合取，即可完整刻画整个链表的状态。

当程序修改数据结构时，部分节点的局部条件会被破坏。为此，引入破坏集（Broken Set，记作 Br），用于记录当前不满足 LC 的节点。每次字段更新后，先执行$"Br" := "Br" + {x}$将该节点加入 Br；随后，用户通过幽灵代码更新 keys、rank 等字段，使其重新满足局部条件；最后通过$"assert LC(x); Br := Br - {x};"$。将节点从 Br 中移除。当所有节点的局部条件重建且 Br 恢复为空集时，即完成对链表内部定义的验证#footnote("原文中给出了Broken Set相关的可靠性证明，即若最终 Br 为空，则链表的内部定义必然成立")。

例如，要在链表中创建新节点 x5 并插入到 x2 与 x3 之间，可按编写以下代码：

```Cpp
x5 = new(10); 
Br = Br + {x5};

x2.next = x5; 
Br = Br + {x2, x3};

x5.prev = x2;
Br = Br + {x5};

x5.keys = x3.keys + {x5.key}; 
Br = Br + {x2, x5};

x5.rank = (x2.rank + x3.rank) / 2; 
Br = Br + {x2, x3, x5}

assert(LC(x3)); 
Br = Br - {x3}
...
assert(LC(x1)); // Br = Br - {x5}

```

上述示例中，每次对普通字段的赋值语句后都紧跟一次对 Br 的更新——表明该修改破坏了相应节点的局部条件。在完成所有字段与幽灵字段的更新后，Br 最终恢复为空集，意味着整个链表的内部定义得以证明。由于 LC 仅使用线性运算、命题逻辑运算符，且不含一阶量词或递归定义，其检查过程始终是可判定的。

此外，这种写法表达力较强，不仅可以描述单链表和双链表，还能刻画有序链表、平衡树，甚至链表与二叉搜索树等复合（overlaid）数据结构；同时，其规约长度、证明脚本规模及验证耗时均处于可接受范围（详见@murali2024predictable 第5.3节 Table 2）。

在这个框架下，为什么简单、可判定的逻辑基础能够表达如此丰富的规约？这个框架的逻辑基础究竟是什么？如果仅从规约表达式的角度来看，它似乎只是算术逻辑、命题逻辑等简单的可判定逻辑；但一旦将证明过程以及 Broken Set 纳入考量，就会发现它实际上隐含了存在量词和全称量词——每个对象对应的幽灵字段，本质上就是一个存在量词；而全称量词则体现在全局规约中，例如链表定义中的" $forall (x: "Loc"). "List"(x) => …$ "这样的形式。更进一步，这里的全称量词通过 Broken Set 间接维护：

$forall (x: "Loc"). "LC"(x) <=> { x :"Loc" | not "LC"(x)} = emptyset <=> "Br" = emptyset$。 

同样，对于分离逻辑中的分离性和归纳定义中的递减性，也可以借助内部定义进行一定程度的表达。例如在下面二叉树的内在定义中（见图），随着树结构向下展开，rank 保证了结构的递降性；而父指针 p 的唯一性则确保了子节点之间的分离性——若有两个不同对象 x1、x2 都作为 y 的子节点，则不可能同时使 p(y)=x1 且 p(y)=x2 成立。

#figure(
  image("images/binary.png", width: 90%)
)

从这一视角来看，该工作格外精妙：它将存在量词与最外层全称量词的证明隐式交给用户，通过幽灵字段、幽灵变量和 Broken Set 来管理，不仅没有显著增加用户的工作负担，反而使验证条件的检查保持在可判定逻辑范围内因而降低了心智负担，为我们提供了极具启发性的思路。

// Blank Here

== 展望

通过上述两个验证工具的例子，我们可以看到：并非越多的自动化启发式策略就越好。在复杂逻辑遇到 unknown 时，过度依赖自动化往往会让用户陷入困境。相反，如果在工具设计层面（包括规约语言的设计和用户交互方式的设计）合理分配验证任务，让用户承担适量的证明义务，再将剩余证明交由自动求解器完成，就能显著优化使用体验，降低学习成本与心智负担。

从形式化证明规则出发，寻找用户与自动化求解器之间的合适分工，是一个很好的切入点。未来的研究可以着力于：识别哪些证明义务更适合由人工撰写（对应特定的证明规则），并设计简介、恰当的交互方式让用户完成这些部分；同时确保剩余证明在交给自动化工具处理后，避免复杂的自动化启发式策略带来的理解障碍。

